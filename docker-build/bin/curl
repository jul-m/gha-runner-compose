#!/bin/sh
########################################################################################################################
##  File:  docker-build/bin/curl
##  Desc:  curl wrapper for gha-runner-compose builds: Adds caching and optional GitHub authentication
########################################################################################################################

set -eu

CACHE_DIR="${GHA_FETCH_CACHE_DIR:-/var/cache/gha-download-cache}"

# Get GITHUB_TOKEN from env or Docker secret
# Pull a fallback token from Docker secrets when the environment variable is absent.
if [ "${GITHUB_TOKEN:-}" = "" ] && [ -f /run/secrets/GITHUB_TOKEN ]; then
  token_from_secret="$(tr -d '\r\n' < /run/secrets/GITHUB_TOKEN 2>/dev/null || true)"
  if [ "${token_from_secret:-}" != "" ]; then
    GITHUB_TOKEN="$token_from_secret"
  fi
fi

# Determine if we should inject an Authorization header.
# Simplified logic: inject token if GITHUB_TOKEN exists and any URL is a GitHub domain.
# This avoids complex parsing of existing headers which is error-prone in POSIX sh.
should_add_auth=0
if [ "${GITHUB_TOKEN:-}" != "" ]; then
  # Look for a GitHub-like URL in args
  for candidate in "$@"; do
    case "$candidate" in
      https://github.com/*|https://api.github.com/*|https://raw.githubusercontent.com/*|https://objects.githubusercontent.com/*)
        should_add_auth=1
        break
        ;;
    esac
  done
fi

AUTH_HEADER=""
if [ $should_add_auth -eq 1 ]; then
  AUTH_HEADER="Authorization: Bearer $GITHUB_TOKEN"
fi

# Execute the real curl binary, optionally injecting the Authorization header discovered above.
run_real_curl() {
  if [ $should_add_auth -eq 1 ]; then
    "$REAL_CURL" -H "$AUTH_HEADER" "$@"
  else
    "$REAL_CURL" "$@"
  fi
}

# Locate the first real curl binary in PATH that isn't this wrapper.
find_real() {
  name="$1"
  self="$0"
  for d in /usr/bin /bin /usr/local/bin /opt/homebrew/bin /usr/local/sbin /usr/sbin /sbin; do
    if [ -x "$d/$name" ] && [ "$d/$name" != "$self" ]; then
      printf '%s' "$d/$name"
      return 0
    fi
  done
  cand="$(command -v "$name" 2>/dev/null || true)"
  if [ "${cand:-}" != "" ] && [ "$cand" != "$self" ]; then
    printf '%s' "$cand"
    return 0
  fi
  return 1
}

# Bail out early when we cannot resolve a genuine curl binary.
REAL_CURL="$(find_real curl)" || { echo "real curl not found" >&2; exit 1; }

# Parse minimal flags in POSIX sh
OUT=""
USE_CAP_O=0
URL=""
NONOPT_COUNT=0
HAS_W=0
W_VAL=""
EXPECT_OUT=0
SKIP_NEXT=0

# Minimal positional parser: capture the first URL, output expectations and relevant flags.
i=1
while [ $i -le $# ]; do
  eval a="\${$i}"
  
  if [ $SKIP_NEXT -eq 1 ]; then
    SKIP_NEXT=0
    i=$((i+1))
    continue
  fi
  
  case "$a" in
    --proto|--tlsv1.2|--proto=*|--tlsv1.2=*|--progress-bar|--silent|--location|--fail|--show-error|--create-dirs|--retry|--retry-delay|--connect-timeout)
      # Skip curl protocol/TLS options and other standard options
      if [ "${a#*=}" = "$a" ]; then
        # No = in argument, value is next argument (only for some options that take values)
        case "$a" in
          --proto|--tlsv1.2|--retry|--retry-delay|--connect-timeout)
            SKIP_NEXT=1
            ;;
        esac
      fi
      ;;
    --retry=*|--retry-delay=*|--connect-timeout=*|--create-dirs)
      # Options with = or no argument
      ;;
    -[fsSLk]*)
      # Common combined short options: -f, -s, -S, -L, -k and combinations like -sSL, -fsSL
      # These don't take arguments
      ;;
    -o|--output)
      i=$((i+1))
      eval OUT="\${$i:-}"
      ;;
    -??*o*|-?o*)
      # Combined short options cluster containing -o (e.g., -4sSLo)
      # The next argument should be the output file
      i=$((i+1))
      eval OUT="\${$i:-}"
      ;;
    *o-*)
      # combined short options containing o- (e.g. -fsSo-)
      OUT="-"
      ;;
    -O)
      USE_CAP_O=1
      ;;
    -O-)
      # explicit -O- treat as stdout
      OUT="-"
      ;;
    -w)
      HAS_W=1
      i=$((i+1)) # capture format value
      eval W_VAL="\${$i:-}"
      ;;
    -*)
      ;;
    *)
      URL="$a"
      NONOPT_COUNT=$((NONOPT_COUNT+1))
      ;;
  esac
  i=$((i+1))
done

# Intercept only the simplest safe case: one URL with an explicit output target.
if [ "${URL:-}" = "" ] || [ $NONOPT_COUNT -ne 1 ]; then
  run_real_curl "$@"
  exit $?
fi

if [ $USE_CAP_O -eq 1 ] && [ "${OUT:-}" = "" ]; then
  # derive output from URL basename
  OUT=$(basename "${URL%%\?*}")
fi

if [ "${OUT:-}" = "" ]; then
  run_real_curl "$@"
  exit $?
fi

# Compute a stable cache key derived from the requested URL.
KEY=""
if command -v sha256sum >/dev/null 2>&1; then
  KEY=$(printf '%s' "$URL" | sha256sum | awk '{print $1}')
elif command -v shasum >/dev/null 2>&1; then
  KEY=$(printf '%s' "$URL" | shasum -a 256 | awk '{print $1}')
elif command -v md5sum >/dev/null 2>&1; then
  KEY=$(printf '%s' "$URL" | md5sum | awk '{print $1}')
else
  # No hash tool, delegate
  run_real_curl "$@"
  exit $?
fi

CACHE_FILE="$CACHE_DIR/$KEY"
# Use a throwaway file to stage the downloaded payload before publishing it to cache/output.
TMP_FILE="$(mktemp)"

# If caller expects HTTP code via -w, preserve behavior and still cache
if [ $HAS_W -eq 1 ] && [ "${W_VAL}" = "%{http_code}" ]; then
  # Cache hit
  if [ -f "$CACHE_FILE" ]; then
    cp -f "$CACHE_FILE" "$OUT"
    # Print 200 to stdout to satisfy -w '%{http_code}'
    printf '%s' "200"
    exit 0
  fi
  # Cache miss: run real curl, tee the http code so we can decide to cache
  CODE_FILE="$(mktemp)"
  # Capture stdout (the -w output) to a file, then forward it back to stdout for the caller
  run_real_curl "$@" > "$CODE_FILE"
  CURL_EXIT=$?
  HTTP_CODE=$(cat "$CODE_FILE" 2>/dev/null || true)
  cat "$CODE_FILE"
  rm -f "$CODE_FILE"
  # Only cache on 200 and when output file exists
  if [ "${HTTP_CODE}" = "200" ] && [ -s "$OUT" ]; then
    cp -f "$OUT" "$CACHE_FILE"
  fi
  exit "$CURL_EXIT"
fi

# No -w: standard cache flow using our own fetch helper.
if [ -f "$CACHE_FILE" ]; then
  cp -f "$CACHE_FILE" "$OUT"
  exit 0
fi

if run_real_curl -L --fail -sS -o "$TMP_FILE" "$URL"; then
  mv "$TMP_FILE" "$CACHE_FILE"
  cp -f "$CACHE_FILE" "$OUT"
  exit 0
else
  rm -f "$TMP_FILE"
  run_real_curl "$@"
  exit $?
fi
